{
  "title": "Database Performance Tuning Guide",
  "category": "database",
  "content": "This knowledge base article provides comprehensive guidance on database performance tuning for PostgreSQL in production environments.",
  "tags": ["database", "postgresql", "performance", "tuning"],
  "metadata": {
    "service": "database",
    "severity": "medium",
    "component": "postgres",
    "team": "data-platform",
    "last_updated": "2024-01-15",
    "version": "2.1"
  },
  "steps": [
    {
      "title": "Identify Performance Bottlenecks",
      "description": "Use monitoring tools to identify slow queries and resource constraints",
      "commands": [
        "SELECT query, mean_time, calls FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 10;",
        "SELECT * FROM pg_stat_activity WHERE state = 'active';",
        "SELECT * FROM pg_stat_database WHERE datname = 'your_database';"
      ],
      "expected_output": "List of slowest queries with execution times and call counts",
      "troubleshooting": "If no queries appear, ensure pg_stat_statements extension is enabled"
    },
    {
      "title": "Analyze Query Execution Plans",
      "description": "Use EXPLAIN ANALYZE to understand query performance",
      "commands": [
        "EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';",
        "EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM orders WHERE created_at > '2024-01-01';"
      ],
      "expected_output": "Detailed execution plan with timing and buffer usage information",
      "troubleshooting": "Look for sequential scans, missing indexes, or high buffer usage"
    },
    {
      "title": "Optimize Indexes",
      "description": "Create and maintain appropriate indexes for better query performance",
      "commands": [
        "CREATE INDEX CONCURRENTLY idx_users_email ON users(email);",
        "CREATE INDEX CONCURRENTLY idx_orders_created_at ON orders(created_at);",
        "ANALYZE users, orders;"
      ],
      "expected_output": "Indexes created successfully without blocking operations",
      "troubleshooting": "Use CONCURRENTLY to avoid blocking writes during index creation"
    },
    {
      "title": "Tune Connection Pool Settings",
      "description": "Configure connection pool parameters for optimal performance",
      "commands": [
        "SHOW max_connections;",
        "SHOW shared_buffers;",
        "SHOW effective_cache_size;"
      ],
      "expected_output": "Current connection and memory configuration values",
      "troubleshooting": "Adjust based on available memory and expected connection load"
    },
    {
      "title": "Monitor and Validate Changes",
      "description": "Verify performance improvements and monitor for regressions",
      "commands": [
        "SELECT * FROM pg_stat_user_tables WHERE schemaname = 'public';",
        "SELECT * FROM pg_stat_user_indexes WHERE schemaname = 'public';"
      ],
      "expected_output": "Updated statistics showing improved performance metrics",
      "troubleshooting": "Compare before/after metrics to validate improvements"
    }
  ],
  "troubleshooting": {
    "common_issues": [
      {
        "issue": "Slow query performance",
        "symptoms": "High CPU usage, slow response times",
        "solutions": [
          "Add appropriate indexes",
          "Optimize query structure",
          "Update table statistics with ANALYZE"
        ]
      },
      {
        "issue": "Connection pool exhaustion",
        "symptoms": "Connection timeouts, 'too many connections' errors",
        "solutions": [
          "Increase max_connections",
          "Implement connection pooling",
          "Review application connection usage"
        ]
      },
      {
        "issue": "Memory pressure",
        "symptoms": "High memory usage, swapping",
        "solutions": [
          "Tune shared_buffers",
          "Adjust work_mem",
          "Review effective_cache_size"
        ]
      }
    ],
    "escalation": {
      "level_1": "Check basic configuration and restart if needed",
      "level_2": "Analyze query plans and optimize indexes",
      "level_3": "Review architecture and consider scaling options"
    }
  },
  "monitoring": {
    "key_metrics": [
      "Query execution time (p50, p95, p99)",
      "Connection count and utilization",
      "Cache hit ratio",
      "Lock wait time",
      "Replication lag"
    ],
    "alert_thresholds": {
      "slow_query_threshold": "1 second",
      "connection_utilization": "80%",
      "cache_hit_ratio": "< 95%",
      "replication_lag": "> 1 second"
    },
    "dashboard_queries": [
      "SELECT query, mean_time FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 10;",
      "SELECT count(*) as active_connections FROM pg_stat_activity WHERE state = 'active';",
      "SELECT round(100.0 * sum(blks_hit) / (sum(blks_hit) + sum(blks_read)), 2) as cache_hit_ratio FROM pg_stat_database;"
    ]
  },
  "best_practices": [
    "Regularly analyze and update table statistics",
    "Use EXPLAIN ANALYZE before deploying query changes",
    "Monitor connection pool utilization",
    "Implement proper indexing strategy",
    "Use connection pooling in applications",
    "Set up comprehensive monitoring and alerting"
  ],
  "related_articles": [
    "PostgreSQL Configuration Tuning",
    "Database Backup and Recovery",
    "Connection Pool Management",
    "Query Optimization Techniques"
  ]
}
